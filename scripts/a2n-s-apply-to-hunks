#!/usr/bin/env bash
#           ___                 personal page: https://a2n-s.github.io/
#      __ _|_  )_ _ ___ ___     github   page: https://github.com/a2n-s
#     / _` |/ /| ' \___(_-<     my   dotfiles: https://github.com/a2n-s/dotfiles
#     \__,_/___|_||_|  /__/
#           ___                               _          _           _             _
#      __ _|_  )_ _ ___ ______ __ _ _ __ _ __| |_  _ ___| |_ ___ ___| |_ _  _ _ _ | |__ ___
#     / _` |/ /| ' \___(_-<___/ _` | '_ \ '_ \ | || |___|  _/ _ \___| ' \ || | ' \| / /(_-<
#     \__,_/___|_||_|  /__/   \__,_| .__/ .__/_|\_, |    \__\___/   |_||_\_,_|_||_|_\_\/__/
#                                  |_|  |_|     |__/
# Description:  TODO.
# Dependencies: TODO.
# License:      https://github.com/a2n-s/scripts/blob/main/LICENSE
# Contributors: Stevan Antoine


OPTIONS=$(getopt -o h --long help -n 'a2n-s-apply-to-hunks' -- "$@")
if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
eval set -- "$OPTIONS"

# environment variables.
[ -z "$COMMENT_SYMBOL" ] && COMMENT_SYMBOL="#"
[ -z "$CONFIG_FILE" ] && CONFIG_FILE="$HOME/.config/a2n-s/hunks.json"

# some constants.
BEGIN_MARKER="$COMMENT_SYMBOL+ BEGIN"
END_MARKER="$COMMENT_SYMBOL+ END"
TEMP_MARKER="%%%"  # a temporary marker to ensure blank characters are taken into account.

MISSING_MARKER_ERROR_CODE=1
MISPLACED_MARKERS_ERROR_CODE=2
MISSING_FIELD_ERROR_CODE=3
BAD_ARGUMENTS_ERROR_CODE=4
ARRAY_SIZE_MISMATCH_ERROR_CODE=5

RED="$(tput setaf 1)"
GRN="$(tput setaf 2)"
YLW="$(tput setaf 3)"
BLU="$(tput setaf 4)"
MGT="$(tput setaf 5)"
CYN="$(tput setaf 6)"
OFF="$(tput sgr0)"


log_err () {
    echo "${RED}[ERROR]${OFF} $1" > /dev/stderr;
}


log_warning () {
    echo "${YLW}[WARNING]${OFF} $1" > /dev/stderr;
}


log_debug () {
    echo "${MGT}[DEBUG]${OFF} $1" > /dev/stderr;
}


log_info () {
    echo "${CYN}[INFO]${OFF} $1" > /dev/stderr;
}


log_ok () {
    echo "${GRN}[OK]${OFF} $1" > /dev/stderr;
}


assert_file_exist () {
    [ ! -f "$1" ] && {
        log_err "$0: '$1': No such file or directory"
        return "$BAD_ARGUMENTS_ERROR_CODE";
    }
    return 0
}


expand_user () {
  sed "s|~|$HOME|g; s/\"//g"
}


get_file_from_json () {
  jq ".$1.file" "$CONFIG_FILE" | expand_user
}


check_markers () {
    local file=$1
    local hunk=$2
    # assert the hunk's markers exist.
    local begin_markers=($(grep "^$BEGIN_MARKER:$hunk$" "$file" -n | awk -F: '{print $1}'))
    local end_markers=($(grep "^$END_MARKER:$hunk$" "$file" -n | awk -F: '{print $1}'))
    [ "${#begin_markers[@]}" -eq 0 ] && {
        log_err "'$BEGIN_MARKER:$hunk' marker could not be found in '$file'."
        return "$MISSING_MARKER_ERROR_CODE";
    }
    [ "${#begin_markers[@]}" -gt 1 ] && {
        log_err "There should be exactly 1 '$BEGIN_MARKER:$hunk' marker in '$file'."
        log_err "Got ${#begin_markers[@]} markers on lines ${begin_markers[*]}."
        return "$MISSING_MARKER_ERROR_CODE";
    }
    [ "${#end_markers[@]}" -eq 0 ] && {
        log_err "'$END_MARKER:$hunk' marker could not be found in '$file'."
        return "$MISSING_MARKER_ERROR_CODE";
    }
    [ "${#end_markers[@]}" -gt 1 ] && {
        log_err "There should be exactly 1 '$END_MARKER:$hunk' marker in '$file'."
        log_err "Got ${#end_markers[@]} markers on lines ${end_markers[*]}."
        return "$MISSING_MARKER_ERROR_CODE";
    }

    # assert the hunk's markers are placed correctly.
    local line_begin_marker=${begin_markers[0]}
    local line_end_marker=${end_markers[0]}
    [ "$line_begin_marker" -gt "$line_end_marker" ] && {
        log_err "The '$END_MARKER:$hunk' marker should come after '$BEGIN_MARKER:$hunk'."
        log_err "'$END_MARKER:$hunk' found on line $line_end_marker"
        log_err "'$BEGIN_MARKER:$hunk' found on line $line_begin_marker"
        return "$MISPLACED_MARKERS_ERROR_CODE";
    }

    echo "$line_begin_marker" "$line_end_marker"
}


get_format_from_json () {
    local format=$(jq ".$1.hunks.$2.format" "$CONFIG_FILE")

    [ "$format" == "null" ] && {
        log_err "No format found in $CONFIG_FILE.$1.hunks.$2"
        return "$MISSING_FIELD_ERROR_CODE";
    }
    [ -z "$(echo "$format" | grep "{name}" )" ] && {
        log_err "missing 'name' key in $CONFIG_FILE.$1.hunks.$2"
        return "$MISSING_FIELD_ERROR_CODE";
    }
    [ -z "$(echo "$format" | grep "{color}" )" ] && {
        log_err "missing 'color' key in $CONFIG_FILE.$1.hunks.$2"
        return "$MISSING_FIELD_ERROR_CODE";
    }

    echo "$format" | sed 's/^"//g; s/"$//g; s/\\"/"/g'
}


get_names_from_json () {
    local names=$(jq ".$1.hunks.$2.names" "$CONFIG_FILE")
    [ "$names" == "null" ] && {
        log_err "No names found between lines $CONFIG_FILE.$1.hunks.$2"
        return "$MISSING_FIELD_ERROR_CODE";
    }

    echo "$names" | tail -n+2 | head -n-1 | sed 's/"//g; s/^\s*//g; s/,//g' | tr '\n' ' '
}


assert_name_and_color_sizes () {
    [ "$1" -ne "$2" ] && {
        log_err "Not the same number of colors and names..."
        log_err "Computed $1 colors."
        log_err "Found $2 names in $3"
        return "$ARRAY_SIZE_MISMATCH_ERROR_CODE";
    }
    return 0
}


apply_values_to_hunk () {
    config=$1
    hunk=$2
    shift 2
    values=($@)

    file="$(get_file_from_json "$config")"

    res=$(check_markers "$file" "$hunk")
    code=$?
    [ $code -ne 0 ] && return "$code"
    line_begin_marker=$(echo "$res" | cut -d' ' -f1)
    line_end_marker=$(echo "$res" | cut -d' ' -f2)

    format=$(get_format_from_json "$config" "$hunk")
    code=$?
    [ $code -ne 0 ] && return "$code"
    names=($(get_names_from_json "$config" "$hunk"))
    code=$?
    [ $code -ne 0 ] && return "$code"

    assert_name_and_color_sizes "${#values[@]}" "${#names[@]}" "$CONFIG_FILE.$config.hunks.$hunk.names"
    code=$?
    [ $code -ne 0 ] && return "$code"

    # generate the final maps of values.
    declare -A names_map;
    declare -A values_map;
    for ((i=0; i<"${#names[@]}"; i++));
    do
        names_map[$(echo "${names[$i]}" | cut -d: -f1)]=$(echo "${names[$i]}" | cut -d: -f2)
        values_map[$(echo "${values[$i]}" | cut -d: -f1)]=$(echo "${values[$i]}" | cut -d: -f2)
    done

    # check that the map from the config file uses keys provided as arguments.
    for name in "${!names_map[@]}";
    do
        value_name=${names_map[$name]}
        value=${values_map[$value_name]}
        [ -z "$value" ] && {
            log_err "The '$value_name' value was not given as an argument but is required by '$name'...";
            log_info "See $CONFIG_FILE.$config.hunks.$hunk.names to fix it."
            log_info "The list of provided keys was '${!values_map[*]}'."
            return 1;
        }
    done

    log_info "${BLU}[$file]${OFF} apply ${BLU}'${values[*]}'${OFF} to '${BLU}$config.$hunk${OFF}'"
    # remove the colors inbetween the markers.
    file_no_colors=$(sed -e "/^$BEGIN_MARKER:$hunk$/,/^$END_MARKER:$hunk$/{//!d}" "$file")
    # add the colors.
    for name in "${!names_map[@]}";
    do
        value=${values_map[${names_map[$name]}]}
        line=$(echo "$format" | sed -e "s/{name}/$name/g" -e "s/{color}/$value/g")
        file_no_colors=$(echo "$file_no_colors" | sed "/^$BEGIN_MARKER:$hunk/a $TEMP_MARKER$line" | sed "s/^$TEMP_MARKER//")
    done
    echo "$file_no_colors" > "$file"
    log_ok "${GRN}[$file]${OFF} config successfully applied to hunk '${GRN}$config.$hunk${OFF}'"
}


apply_to_hunks() {
    name=$1
    shift 1

    [ ! -f "$CONFIG_FILE" ] && {
      log_err "CONFIG_FILE: '$CONFIG_FILE': No such file or directory.";
      exit 1;
    }

    [ "$(jq ".$name" "$CONFIG_FILE")" == "null" ] && {
      log_err "'$name' was not found in '$CONFIG_FILE'...";
      exit 1;
    }

    assert_file_exist "$(get_file_from_json "$name")"
    code=$?
    [ $code -ne 0 ] && return "$code"

    [ $(($# % 2)) -ne 0 ] && { log_err "There should be the same number of hunk names and hunks values to apply..."; exit 1; }

    # compute the associative array of named hunks and their respective values.
    declare -A all_values
    while [ "$#" -gt 0 ];
    do
      hunk=$1;
      value=$2;
      shift 2;
      all_values["$hunk"]="$value"
    done

    # apply the values to the hunks.
    for hunk in "${!all_values[@]}";
    do
        apply_values_to_hunk "$name" "$hunk" "${all_values[$hunk]}"
    done
}


usage () {
  #
  # the usage function.
  #
  echo "Usage: a2n-s-apply-to-hunks [-h] CONFIG_NAME HUNK1 VALUES1 HUNK2 VALUES2 ..."
  echo "Type -h or --help for the full help."
}


help () {
  #
  # the help function.
  #
  echo "a2n-s-apply-to-hunks:"
  echo "     This script allows the user to easily apply some configuration to a config file."
  echo "     Do not forget to put it in your PATH."
  echo ""
  echo "Usage:"
  echo "     a2n-s-apply-to-hunks [-h] CONFIG_NAME HUNK1 VALUES1 HUNK2 VALUES2 ..."
  echo ""
  echo "          - CONFIG_NAME is the name of the config in the json config file of this script"
  echo "          - HUNK is the name of the hunk to apply the values to"
  echo "          - VALUES is the list of name:value pairs, as defined in the config file below, to apply to the hunk"
  echo ""
  echo "Switches:"
  echo "     -h/--help               shows this help."
  echo ""
  echo "Environment variables:"
  echo "     COMMENT_SYMBOL          the symbol used to begin comment in the config file (defaults to '#', e.g. for \`bash\` or \`python\`)"
  echo "     CONFIG_FILE             the config file for this script (defaults to '\$HOME/.config/a2n-s/hunks.json')"
  exit 0
}


main () {
  #
  # TODO.
  #
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h | --help ) help ;;
      -- ) shift; break ;;
      * ) break ;;
    esac
  done

  [ -z "$1" ] && {
      log_warning "no file to edit given as first positional argument...";
      log_warning "Terminating...";
      usage;
      return "$BAD_ARGUMENTS_ERROR_CODE";
  }

  config=$1
  shift 1
  apply_to_hunks "$config" "$@"
}


main "$@"
