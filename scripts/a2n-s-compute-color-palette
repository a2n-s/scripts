#!/usr/bin/env python3

import argparse
import numpy as np
from tqdm import trange
import colorsys

Color = str


def is_valid_color(color: Color) -> bool:
    """TODO."""
    return color.startswith("#") and len(color) == 7


def is_valid_rgb(red: int, green: int, blue: int) -> bool:
    """TODO."""
    return (0 <= red <= 255) and (0 <= green <= 255) and (0 <= blue <= 255)


def int_to_color(red: int, green: int, blue: int) -> Color:
    """TODO."""
    if not is_valid_rgb(red, green, blue):
        raise ValueError(
            "Channels should be between 0 and 255, "
            f"got '{red}', '{green}' and '{blue}'."
        )

    color = hex((red << 16) + (green << 8) + (blue << 0)).replace("0x", "")
    return f"#{color:>06}"


def color_to_int(color: Color) -> (int, int, int):
    """TODO."""
    if not is_valid_color(color):
        raise ValueError(f"'color' is not valid, got '{color}'")
    return (
        int(f"0x{color[1:3]}", base=16),
        int(f"0x{color[3:5]}", base=16),
        int(f"0x{color[5:7]}", base=16),
    )


def complete_color_representation(color: str) -> Color:
    """TODO."""
    return f"#{color}" if is_valid_color(f"#{color}") else color


def make_random_color() -> Color:
    """TODO."""
    return int_to_color(
        np.random.randint(0, 256), np.random.randint(0, 256), np.random.randint(0, 256)
    )


def make_random_colors(names):
    """TODO."""
    return dict(
        zip(
            names,
            [make_random_color() for _ in range(len(names))],
        )
    )


PALETTE_NAMES = [
    "bg",
    "fg",
    "sel_bg",
    "sel_fg",
    "cursor",
    "cl0",
    "cl1",
    "cl2",
    "cl3",
    "cl4",
    "cl5",
    "cl6",
    "cl7",
    "cl8",
    "cl9",
    "cl10",
    "cl11",
    "cl12",
    "cl13",
    "cl14",
    "cl15",
]

GRADIENT_NAMES = [
    "gd0",
    "gd1",
    "gd2",
    "gd3",
    "gd4",
    "gd5",
    "gd6",
    "gd7",
    "gd8",
    "gd9",
    "gd10",
    "gd11",
    "gd12",
    "gd13",
    "gd14",
    "gd15",
    "gd15",
]

NAMES = PALETTE_NAMES + GRADIENT_NAMES


def make_color_theme(light: bool = False):
    """TODO."""
    hsv_black = colorsys.rgb_to_hsv(0.0, 0.0, 0.0)
    hsv_grey = colorsys.rgb_to_hsv(0.2, 0.2, 0.2)
    hsv_red = colorsys.rgb_to_hsv(1.0, 0.0, 0.0)
    hsv_green = colorsys.rgb_to_hsv(0.0, 1.0, 0.0)
    hsv_yellow = colorsys.rgb_to_hsv(1.0, 1.0, 0.0)
    hsv_blue = colorsys.rgb_to_hsv(0.0, 0.0, 1.0)
    hsv_magenta = colorsys.rgb_to_hsv(1.0, 0.0, 1.0)
    hsv_cyan = colorsys.rgb_to_hsv(0.0, 1.0, 1.0)
    hsv_white = colorsys.rgb_to_hsv(1.0, 1.0, 1.0)
    color_theme = {
        "bg": hsv_black,
        "fg": hsv_white,
        "sel_bg": hsv_white,
        "sel_fg": hsv_black,
        "cursor": hsv_white,
        "cl8": hsv_grey,
        "cl9": hsv_red,
        "cl10": hsv_green,
        "cl11": hsv_yellow,
        "cl12": hsv_blue,
        "cl13": hsv_magenta,
        "cl14": hsv_cyan,
        "cl15": hsv_white,
    }
    color_theme["cl0"] = tuple(np.array([1, 1, .8]) * np.array(color_theme["cl8"]))
    color_theme["cl1"] = tuple(np.array([1, 1, .8]) * np.array(color_theme["cl9"]))
    color_theme["cl2"] = tuple(np.array([1, 1, .8]) * np.array(color_theme["cl10"]))
    color_theme["cl3"] = tuple(np.array([1, 1, .8]) * np.array(color_theme["cl11"]))
    color_theme["cl4"] = tuple(np.array([1, 1, .8]) * np.array(color_theme["cl12"]))
    color_theme["cl5"] = tuple(np.array([1, 1, .8]) * np.array(color_theme["cl13"]))
    color_theme["cl6"] = tuple(np.array([1, 1, .8]) * np.array(color_theme["cl14"]))
    color_theme["cl7"] = tuple(np.array([1, 1, .8]) * np.array(color_theme["cl15"]))

    return {key: int_to_color(*(np.array(colorsys.hsv_to_rgb(*value)) * 255).astype(int)) for key, value in color_theme.items()}


def get_gradient_end_points(theme, args):
    """TODO."""
    if args.random_gradient:
        gradient_start = make_random_color()
        gradient_end = make_random_color()
    else:
        # get the colors given as arguments.
        gradient_start = complete_color_representation(args.gds)
        gradient_end = complete_color_representation(args.gde)

        if not is_valid_color(gradient_start):
            gradient_start = theme[gradient_start]
        if not is_valid_color(gradient_end):
            gradient_end = theme[gradient_end]

    return gradient_start, gradient_end


def compute_color_gradient(
    c1: Color,
    c2: Color,
    *,
    nb_colors: int = 2,
    reverse: bool = False,
    verbose: bool = False,
):
    """TODO."""
    if nb_colors < 2:
        raise ValueError(f"'nb_colors' should be at least 2, got '{nb_colors}'.")
    r1, g1, b1 = color_to_int(c1)
    r2, g2, b2 = color_to_int(c2)
    if verbose:
        print(f"{c1} -> ({r1}, {g1}, {b1})")
        print(f"{c2} -> ({r2}, {g2}, {b2})")
    red_gradient = np.linspace(r1, r2, nb_colors).astype(int)
    green_gradient = np.linspace(g1, g2, nb_colors).astype(int)
    blue_gradient = np.linspace(b1, b2, nb_colors).astype(int)
    if verbose:
        print(f"red: {red_gradient}")
        print(f"green: {green_gradient}")
        print(f"blue: {blue_gradient}")
    ziped_gradients = list(zip(red_gradient, green_gradient, blue_gradient))
    if reverse:
        ziped_gradients = reversed(ziped_gradients)
    return [int_to_color(r, g, b) for (r, g, b) in ziped_gradients]


def test():
    """TODO."""
    for r in trange(256, desc="Testing the color conversions"):
        for g in range(256):
            for b in range(256):
                assert (r, g, b) == color_to_int(int_to_color(r, g, b))
    for i in trange(100000, desc="Testing the random color generation"):
        assert is_valid_rgb(*color_to_int(make_random_color()))
    print("Tests are successful!!")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=(
            f"{PALETTE_NAMES = }"
            "\n"
            f"{GRADIENT_NAMES = }"
        ),
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "-1",
        "--gds",
        type=str,
        default="#ff0000",
        help=(
            f"the first color of the gradient, i.e. \"{GRADIENT_NAMES[0]}\", "
            "of the form '#rrggbb' or a name in 'PALETTE_NAMES' "
            "(defaults to red, i.e '#ff0000')."
        ),
    )
    parser.add_argument(
        "-2",
        "--gde",
        type=str,
        default="#00ff00",
        help=(
            f"the last color of the gradient, i.e. \"{GRADIENT_NAMES[-1]}\", "
            "of the form '#rrggbb' or a name in 'PALETTE_NAMES' "
            "(defaults to green, i.e '#00ff00')."
        ),
    )
    parser.add_argument(
        "-g",
        "--gradient_only",
        action="store_true",
        help="print the gradient only (defaults to 'False').",
    )
    parser.add_argument(
        "-l",
        "--light",
        action="store_true",
        help="turns on light theme mode (defaults to false, i.e dark theme).",
    )
    parser.add_argument(
        "-r",
        "--reverse",
        action="store_true",
        help="print the gradient in reverse (defaults to 'False').",
    )
    parser.add_argument(
        "-G",
        "--random_gradient",
        action="store_true",
        help=(
            "use random colors for the two ends of the gradient, i.e. "
            f"\"{GRADIENT_NAMES[0]}\" to \"{GRADIENT_NAMES[-1]}\" keys in "
            "'GRADIENT_NAMES' (defaults to 'False'). Overwrites -1 and -2."
        ),
    )
    parser.add_argument(
        "-R",
        "--random_palette",
        action="store_true",
        help=(
            "use random colors for the whole palette, i.e. all the keys in "
            "'PALETTE_NAMES' or 'GRADIENT_NAMES' "
            "(defaults to 'False'). Overwrites -G, -1 and -2."
        ),
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="be more verbose (defaults to 'False').",
    )
    parser.add_argument(
        "-t",
        "--test",
        action="store_true",
        help="run the tests (defaults to 'False').",
    )

    args = parser.parse_args()

    if args.test:
        test()
    else:
        if args.random_palette:
            # all the colors should be completely random.
            palette = make_random_colors(names=NAMES)
        else:
            color_theme = make_color_theme(light=args.light)

            gd_start, gd_end = get_gradient_end_points(color_theme, args)

            gradient_colors = compute_color_gradient(
                gd_start,
                gd_end,
                nb_colors=len(GRADIENT_NAMES),
                reverse=args.reverse,
                verbose=args.verbose,
            )
            color_gradient = dict(zip(GRADIENT_NAMES, gradient_colors))

            if args.gradient_only:
                palette = color_gradient
            else:
                palette = {**color_theme, **color_gradient}

        print("\n".join([f"{key}:{value}" for key, value in palette.items()]))
