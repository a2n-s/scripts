#!/usr/bin/env bash

OPTIONS=$(getopt -o h --long help -n 'a2n-s-apply-theme' -- "$@")
if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
eval set -- "$OPTIONS"

# environment variables.
[ -z "$COMMENT_SYMBOL" ] && COMMENT_SYMBOL="#"

# some constants.
BEGIN_MARKER="$COMMENT_SYMBOL+ BEGIN"
END_MARKER="$COMMENT_SYMBOL+ END"
FORMAT_MARKER="$COMMENT_SYMBOL+ format"
NAMES_MARKER="$COMMENT_SYMBOL+ names"
TEMP_MARKER="%%%"  # a temporary marker to ensure blank characters are taken into account.

MISSING_MARKER_ERROR_CODE=1
MISPLACED_MARKERS_ERROR_CODE=2
MISSING_FIELD_ERROR_CODE=3
BAD_ARGUMENTS_ERROR_CODE=4
ARRAY_SIZE_MISMATCH_ERROR_CODE=5

RED="$(tput setaf 1)"
GRN="$(tput setaf 2)"
YLW="$(tput setaf 3)"
BLU="$(tput setaf 4)"
MGT="$(tput setaf 5)"
CYN="$(tput setaf 6)"
OFF="$(tput sgr0)"


log_err () {
    echo "${RED}[ERROR]${OFF} $1" > /dev/stderr;
}


log_warning () {
    echo "${YLW}[WARNING]${OFF} $1" > /dev/stderr;
}


log_debug () {
    echo "${MGT}[DEBUG]${OFF} $1" > /dev/stderr;
}


log_info () {
    echo "${CYN}[INFO]${OFF} $1" > /dev/stderr;
}


log_ok () {
    echo "${GRN}[OK]${OFF} $1" > /dev/stderr;
}


assert_file_exist () {
    [ ! -f "$1" ] && {
        log_err "$0: '$1': No such file or directory"
        return "$BAD_ARGUMENTS_ERROR_CODE";
    }
    return 0
}


check_markers () {
    local theme_file=$1
    local name=$2
    # assert color-theme markers exist.
    local begin_markers=($(grep "^$BEGIN_MARKER:$name$" "$theme_file" -n | awk -F: '{print $1}'))
    local end_markers=($(grep "^$END_MARKER:$name$" "$theme_file" -n | awk -F: '{print $1}'))
    [ "${#begin_markers[@]}" -ne 1 ] && {
        log_err "There should be exactly 1 '$BEGIN_MARKER:$name' marker in '$theme_file'."
        log_err "Got ${#begin_markers[@]} markers on lines ${begin_markers[*]}."
        return "$MISSING_MARKER_ERROR_CODE";
    }
    [ "${#end_markers[@]}" -ne 1 ] && {
        log_err "There should be exactly 1 '$END_MARKER:$name' marker in '$theme_file'."
        log_err "Got ${#end_markers[@]} markers on lines ${end_markers[*]}."
        return "$MISSING_MARKER_ERROR_CODE";
    }

    # assert color-theme markers are placed correctly.
    local line_begin_marker=${begin_markers[0]}
    local line_end_marker=${end_markers[0]}
    [ "$line_begin_marker" -gt "$line_end_marker" ] && {
        log_err "The '$END_MARKER:$name' marker should come after '$BEGIN_MARKER:$name'."
        log_err "'$END_MARKER:$name' found on line $line_end_marker"
        log_err "'$BEGIN_MARKER:$name' found on line $line_begin_marker"
        return "$MISPLACED_MARKERS_ERROR_CODE";
    }

    echo "$line_begin_marker" "$line_end_marker"
}


# extract meta data from the color-theme marker
get_marker_zone () {
  sed -n "/^$BEGIN_MARKER:$2$/,/^$END_MARKER:$2$/p" "$1"
}


check_format () {
    local line_begin_marker=$1
    local line_end_marker=$2
    local theme_file=$3
    local format=$4

    [ -z "$format" ] && {
        log_err "No format found between lines $line_begin_marker and $line_end_marker of $theme_file..."
        log_err "Please make sur the '$FORMAT_MARKER' field is correct."
        return "$MISSING_FIELD_ERROR_CODE";
    }
    [ -z "$(echo "$format" | grep "{name}" )" ] && {
        log_err "missing 'name' key in format '$format' between lines $line_begin_marker and $line_end_marker of $theme_file..."
        return "$MISSING_FIELD_ERROR_CODE";
    }
    [ -z "$(echo "$format" | grep "{color}" )" ] && {
        log_err "missing 'color' key in format '$format' between lines $line_begin_marker and $line_end_marker of $theme_file..."
        return "$MISSING_FIELD_ERROR_CODE";
    }
    return 0
}


get_format_from_marker_zone () {
    local format=$(echo "$1" | grep "^$FORMAT_MARKER:.*" | cut -d: -f2-)
    check_format "$2" "$3" "$4" "$format"
    code=$?
    [ $code -ne 0 ] && return "$code"

    echo "$format"
}


get_names_from_marker_zone () {
    local names=()
    names=($(echo "$marker_zone" | grep "^$NAMES_MARKER:.*" | awk -F: '{print $2}' | tr ',' ' '))
    [ "${#names[@]}" -eq 0 ] && {
        log_err "No names found between lines $line_begin_marker and $line_end_marker of $theme_file..."
        log_err "Please make sur the '$NAMES_MARKER' field is correct."
        return "$MISSING_FIELD_ERROR_CODE";
    }
    echo "${names[@]}"
}


assert_name_and_color_sizes () {
    [ "$1" -ne "$2" ] && {
        log_err "Not the same number of colors and names..."
        log_err "Computed $1 colors."
        log_err "Found $2 names in $3"
        return "$ARRAY_SIZE_MISMATCH_ERROR_CODE";
    }
    return 0
}


apply_palette_to_hunk () {
    theme_file=$1
    name=$2
    shift 2
    palette=($@)

    res=$(check_markers "$theme_file" "$name")
    code=$?
    [ $code -ne 0 ] && return "$code"
    line_begin_marker=$(echo "$res" | cut -d' ' -f1)
    line_end_marker=$(echo "$res" | cut -d' ' -f2)

    marker_zone=$(get_marker_zone "$theme_file" "$name")
    code=$?
    [ $code -ne 0 ] && return "$code"

    format=$(get_format_from_marker_zone "$marker_zone" "$line_begin_marker" "$line_end_marker" "$theme_file")
    code=$?
    [ $code -ne 0 ] && return "$code"
    names=($(get_names_from_marker_zone "$marker_zone" "$line_begin_marker" "$line_end_marker" "$theme_file"))
    code=$?
    [ $code -ne 0 ] && return "$code"

    assert_name_and_color_sizes "${#palette[@]}" "${#names[@]}" "$theme_file"
    code=$?
    [ $code -ne 0 ] && return "$code"

    log_info "${BLU}[$theme_file]${OFF} apply ${BLU}'${palette[*]}'${OFF} to hunk '${BLU}$name${OFF}'"
    # remove the colors inbetween the markers.
    file_no_colors=$(sed -e "/^$BEGIN_MARKER:$name$/,/^$END_MARKER:$name$/{//!d}" "$theme_file")
    # add the colors.
    for ((i=(("${#palette[@]}"-1)); i>=0; i--)) ;
    do
        line=$(echo "$format" | sed -e "s/{name}/${names[$i]}/g" -e "s/{color}/${palette[$i]}/g")
        file_no_colors=$(echo "$file_no_colors" | sed "/^$BEGIN_MARKER:$name/a $TEMP_MARKER$line" | sed "s/^$TEMP_MARKER//")
    done
    # add the fields back.
    file_no_colors=$(echo "$file_no_colors" | sed "/^$BEGIN_MARKER:$name/a $NAMES_MARKER:$(echo "${names[*]}" | tr ' ' ',')")
    file_no_colors=$(echo "$file_no_colors" | sed "/^$BEGIN_MARKER:$name/a $FORMAT_MARKER:$format")
    echo "$file_no_colors" > "$theme_file"
    log_ok "${GRN}[$theme_file]${OFF} theme successfully applied to hunk '${GRN}$name${OFF}'"
}


apply_theme() {
    theme_file="$1"
    shift 1

    assert_file_exist "$theme_file"
    code=$?
    [ $code -ne 0 ] && return "$code"

    # compute the associative array of named hunks and their respective color palettes.
    declare -A palettes
    for arg in "$@";
    do
      name=$(echo "$arg" | cut -d= -f1)
      value=$(echo "$arg" | cut -d= -f2)
      palettes["$name"]="$value"
    done

    # apply the palettes to the hunks.
    for name in "${!palettes[@]}";
    do
        apply_palette_to_hunk "$theme_file" "$name" "${palettes[$name]}"
    done
}


usage () {
  #
  # the usage function.
  #
  echo "Usage: a2n-s-apply-theme [-h] CONFIG_FILE NAME1=PALETTE1 NAME2=PALETTE2 ..."
  echo "Type -h or --help for the full help."
}


help () {
  #
  # the help function.
  #
  echo "a2n-s-apply-theme:"
  echo "     This script allows the user to easily apply a theme to a config file."
  echo "     Do not forget to put it in your PATH."
  echo ""
  echo "Usage:"
  echo "     a2n-s-apply-theme [-h] CONFIG_FILE NAME1=PALETTE1 NAME2=PALETTE2 ..."
  echo ""
  echo "          - CONFIG_FILE is the path to the config file to edit"
  echo "          - NAME is the name of the hunk to apply the theme to"
  echo "          - PALETTE is the list of colors to apply to the config file"
  echo ""
  echo "Switches:"
  echo "     -h/--help               shows this help."
  echo ""
  echo "Environment variables:"
  echo "     COMMENT_SYMBOL          the symbol used to begin comment in the config file (defaults to '#', e.g. for \`bash\` or \`python\`)"
  exit 0
}


main () {
  #
  # TODO.
  #
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h | --help ) help ;;
      -- ) shift; break ;;
      * ) break ;;
    esac
  done

  [ -z "$1" ] && {
      log_warning "no file to edit given as first positional argument...";
      log_warning "Terminating...";
      usage;
      return "$BAD_ARGUMENTS_ERROR_CODE";
  }

  file=$1
  shift 1
  apply_theme "$file" "$@"
}


main "$@"
